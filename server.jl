#=
server.jl <port> will start an interactive game
session, facilitating a connection between two
players. The server should listen on the port
given. The server makes no moves, only makes
sure that two players connecting to it can play the
game. This should mean passing messages from
one player to another, and declaring the winner.
You need to handle disconnects gracefully. A disconnect
terminates the game. You only need to
handle one game at a time.

"<wincode>:<authString>:<movenum>:<movetype>:<sourcex>:<sourcey>
:<targetx>:<targety>:<option>:<cheating>:<targetx2>:<targety2>:<targetx3>:<targety3>"
The authstring is a secret code generated by the server that only the individual player knows.
The client/player must send this code with every move
=#

##IF sending from CLIENT

wcc_requestGame = "0"
wcc_quitGame = "1"
wcc_playMove = "2"
wcc_opponentCheating = "3"
wcc_badPayload = "10"
wcc_message = "M"

##IF sending from SERVER

# WINCODES
wcs_playerOne = "0"
wcs_playerTwo = "1"
wcs_serverQuits = "2"
wcs_draw = "3"
wcs_notYourTurn = "8"
wcs_yourTurn = "9"
wcs_badPayload = "10"
wcs_error = "e"

# LEGALITY
legal_cheating = "0"
legal_true = "1"

# GAME TYPE

game_standard = "S"
game_mini = "M"
game_chu = "C"
game_tenjiku = "T"

# MOVE TYPE
move_move = "1"
move_drop = "2"
move_resign = "3"

# OPTION
option_null = "0"
option_promote = "!"

# I_AM_CHEATING
cheating_null = "0"
cheating_true = "1"

# STATES
state_wait_first = "0"
state_wait_second = "1"
state_message_first = "2"
state_message_second = "3"
number_of_states = "4"

function initialize()
  # global variables
  global state = state_wait_first
  # defaults to a standard game that is untimed and cheating not allowed.
  # default game parameters
  global game_type = game_standard
  global game_legality = legal_true
  # we will use value 0 for "unlimited"
  global game_total_time = "0"
  global game_turn_time = "0"
  global client_one_auth = ""
  global client_two_auth = ""
end

function main()
  port = parse(Int, ARGS[1])
  server = listen(port)
  # first call to listen() will create a server waiting
  # for incoming connections on the specified port (2000)
  while true
    socket=accept(server)
    message = readline(socket)
    runStateMachine(socket, message)
  end
end

#"<request game>: <standard shogi>: <no cheating>: <100 seconds>: <10 seconds per turn>"
function runStateMachine(socket, message)
  global state
  global game_type
  global game_legality
  global game_total_time
  global game_turn_time
  global client_one_auth
  global client_two_auth

  fields = split(message, ':')
  for i in 1 : length(fields)
    fields[i] = chomp(fields[i])
  end
  #TBR
  println("Entering state machine")
  println("State: $state")
  println("Fields")
  for (index, value) in enumerate(fields)
    println("$index $value")
  end

  if state == state_wait_first
    # the only valid message is "game initialization"
    if fields[1] != wcc_requestGame
      #send error message
      write(socket, "e:You didn't register a game\n")
      return
    end
    # go throug requested game parameters
    # if any of them is not valid, do not send back an error message
    # just leave a default value that is already pre-set
    if length(fields) > 1
      if fields[2] == game_standard || fields[2] == game_mini || fields[2] == game_chu || fields[2] == game_tenjiku
        game_type = fields[2]
      end
    end

    if length(fields) > 2
      if fields[3] == legal_cheating || fields[3] == legal_true
        game_legality = fields[3]
      end
    end

    if length(fields) > 3
      game_total_time = fields[4] # parse(Int64, fields[4])
    end

    if length(fields) > 4
      game_turn_time = fields[5] #parse(Int64, fields[5])
    end

    # generate authentication code for the client
    client_one_auth = randstring()
    # send back confirmation message with game parameters
    reply = string(wcs_playerOne, ":", client_one_auth, ":", game_type, ":", game_legality, ":", game_total_time, ":", game_turn_time, "\n")
    write(socket, reply)

    # change state
    state = state_wait_second
  elseif state == state_wait_second
    if fields[1] == wcc_requestGame
      client_two_auth = randstring()
    else
      write(socket, "e:You didn't register a game\n")
      return
    end

    reply = string(wcs_playerTwo, ":", client_two_auth, ":", game_type, ":", game_legality, ":", game_total_time, ":", game_turn_time, "\n")
    write(socket, reply)

    state = state_message_first
  elseif state == state_message_first || state == state_message_second

    # once connected to the server,
    # clients can send each other custom messages at any time
    if fields[1] == wcc_message
      reply = "\n"
      # if sent by client one, pass it to client two
      if fields[2] == client_one_auth
        reply = string(fields[1], ":", client_two_auth, ":", fields[3], "\n")
      elseif fields[2] == client_two_auth
        reply = string(fields[1], ":", client_one_auth, ":", fields[3], "\n")
      end
      # if the message was not sent by any of our cllients, ignore it
      if reply != ""
        write(socket, reply)
      end
      return
    end

    if fields[1] == wcc_requestGame
      write(socket, "e:Invalid wincode\n")
      return
    end

    if fields[1] == wcc_quitGame || fields[1] == wcc_opponentCheating
      # send draw message to both clients
      reply = string(wcs_draw, ":", client_one_auth, "\n")
      write(socket, reply)
      reply = string(wcs_draw, ":", client_two_auth, "\n")
      write(socket, reply)
      #reset the machine
      initialize()
      return
    end

    if fields[1] == wcc_badPayload
      write(socket, "e:Bad payload\n")
      return
    end

    if fields[1] != wcc_playMove
      write(socket, "e:Bad payload\n")
      return
    end

    # wincode is correct
    if state == state_message_first
      # make sure that we received a move message from player one
      if fields[2] != client_one_auth
        reply = string(wcs_notYourTurn, ":", fields[2], "\n")
        write(socket, reply)
        return
      end

      # we have a valid "move" message sent from client one
      # pass it to client two
      reply = replace(message, ":", client_one_auth, ":", client_two_auth, "\n")
      write(socket, reply)
      # and wait for a message from client two
      state = state_message_second
    end

    if state == state_message_second
      # make sure that we received a move message from player two
      if fields[2] != client_two_auth
        reply = string(wcs_notYourTurn, ":", fields[2], "\n")
        write(socket, reply)
        return
      end

      # we have a valid "move" message sent from client two
      # pass it to client one
      reply = replace(message, ":", client_two_auth, ":", client_one_auth, "\n")
      write(socket, reply)
      # and wait for a message from client two
      state = state_message_first
    end
  else
    println("Wrong state!")
  end
end

initialize()
main()
#if wincode=0; start of a game

#The server responds with the wincode specifying if they are second or first as well
# as an auth code that must be included in every set of information sent to the server
#What server receives

#"<wincode>: <gametype>: <legality>: <timelimit>: <limitadd>"
#What server sends

#"<wincode>:<authString>:<gametype>:<legality>:<timelimit>:<limitadd>‚Äù
#wincode:player 1 (0) or 2 (1)
#=
function gameInitialization(payload_C)

  payload=split(payload_C,":")
  payloadToClient=[]
  if payload[1]=='0'
    #begin a game
  end
  #Finding the gametype
  if payload[2]=='S' || payload[2]=='s'
    gameType = 'S'
    #standard
  elseif payload[2]=='M' || payload[2]=='m'
    gameType = 'M'
    #minishogi
  elseif payload[2]=='C' || payload[2]=='c'
    gameType = 'C'
    #chu
  else
    #not specified
    println("What.")
  end

  #checking legality of game
  if payload[3]=='0'
    #cheating game
    cheating = true
  elseif payload[3]=='1'
    #non cheating game
    cheating = false
  else
    #not specified
  end

  #new for each game. NOT EACH TURN/COMMUNICATION/MESSAGE
  AuthString = randstring()
end

#listen for payloads with moves, if the payload is valid (read: syntactically correct) forward it to the other player with wincode 9.
#"<wincode>:<authString>:<movenum>:<movetype>:<sourcex>:<sourcey>:<targetx>:<targety>:<option>:<cheating>:<targetx2>:<targety2>"
function serverListen(payload)

end
=#
